# -*- coding: utf-8 -*-
"""ML Terapan - Proyek Akhir

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kOtprSWFz3r3aENjU-qGbeErsj3jNrKo

# Proyek Akhir : Membuat Model Sistem Rekomendasi

## Import Libraries
"""

# Libraries for data manipulation and analysis
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Libraries for preprocessing
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler, LabelEncoder

# Libraries for splitting the data
from sklearn.model_selection import train_test_split

# Libraries for modeling
from sklearn.metrics.pairwise import linear_kernel

# Libraries for evaluation
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

"""## Load Dataset

#### Read dataset
"""

url = 'https://raw.githubusercontent.com/Ardizza/Machine-Learning-Terapan-Final-Project/main/NetflixOriginals.csv'
df = pd.read_csv(url)

"""## Exploratory Data Analysis (EDA)

#### 5 baris pertama dari dataset
"""

print(df.head())

"""#### Informasi dataset"""

print(df.info())

"""#### Statistik Deskriptif

#### Mengecek Jumlah Null
"""

# tidak ada missing values
print(df.isnull().sum())

print(df.describe())

"""### Visualisasi Data"""

sns.histplot(df['IMDB Score'])
plt.title('Distribution of IMDB Scores')
plt.show()

"""## Data Preparation

#### Data Transformation
"""

# Mengubah kolom 'Premiere' menjadi format datetime
df['Premiere'] = pd.to_datetime(df['Premiere'])

# Mengubah kolom 'Premiere' menjadi numerik (ordinal encoding)
df['Premiere'] = df['Premiere'].map(pd.Timestamp.toordinal)

# Encoding kolom 'Language'
le = LabelEncoder()
df['Language'] = le.fit_transform(df['Language'])

"""#### Normalisasi data"""

scaler = StandardScaler()
df_scaled = scaler.fit_transform(df.drop(['Title', 'Genre', 'IMDB Score'], axis=1))

"""#### TF-IDF Vectorizer"""

# Create TF-IDF matrix
tfidf = TfidfVectorizer(stop_words='english')
df['Genre'] = df['Genre'].fillna('')
tfidf_matrix = tfidf.fit_transform(df['Genre'])

"""#### Memisahkan fitur dan label"""

X = df_scaled
y = df['IMDB Score']

"""#### Split data"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""## Modeling

### Content-Based Filtering

#### Cosine similarity matrix
"""

cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

"""#### Get recommendations"""

def get_recommendations(title, cosine_sim=cosine_sim):
    idx = df[df['Title'] == title].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:11]
    movie_indices = [i[0] for i in sim_scores]
    return df['Title'].iloc[movie_indices]

"""#### Example Recommendations"""

print("Recommendations for 'The Irishman':")
print(get_recommendations('The Irishman'))

"""### Collaborative Filtering

#### Create a pivot table
"""

pivot_table = df.pivot_table(index='Title', columns='Genre', values='IMDB Score', fill_value=0)

"""#### Normalize ratings"""

pivot_table = pivot_table.apply(lambda x: (x - np.mean(x))/(np.max(x)-np.min(x)), axis=1)

"""#### Convert to matrix"""

pivot_matrix = pivot_table.to_numpy()

"""#### Cosine similarity"""

movie_similarity = linear_kernel(pivot_matrix, pivot_matrix)

"""#### Get user recommendations"""

def get_user_recommendations(title, movie_similarity=movie_similarity):
    idx = df[df['Title'] == title].index[0]
    sim_scores = list(enumerate(movie_similarity[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:11]
    movie_indices = [i[0] for i in sim_scores]
    return df['Title'].iloc[movie_indices]

"""#### Example Recommendations"""

print("Recommendations for '13th':")
print(get_recommendations('13th'))

"""## Evaluation

### Split data
"""

train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

"""### Create pivot tables"""

train_pivot = train_data.pivot_table(index='Title', columns='Genre', values='IMDB Score', fill_value=0)
test_pivot = test_data.pivot_table(index='Title', columns='Genre', values='IMDB Score', fill_value=0)

"""### Normalize ratings"""

train_pivot = train_pivot.apply(lambda x: (x - np.mean(x))/(np.max(x)-np.min(x)), axis=1)
test_pivot = test_pivot.apply(lambda x: (x - np.mean(x))/(np.max(x)-np.min(x)), axis=1)

"""### Convert to matrix"""

train_matrix = train_pivot.to_numpy()
test_matrix = test_pivot.to_numpy()

"""### Calculate similarity"""

train_similarity = linear_kernel(train_matrix, train_matrix)
test_similarity = linear_kernel(test_matrix, test_matrix)

"""### Mean Absolute Error (MAE)"""

def mae(pred, actual):
    pred = pred[actual.nonzero()].flatten()
    actual = actual[actual.nonzero()].flatten()
    return mean_absolute_error(pred, actual)

"""### Root Mean Squared Error (RMSE)"""

def rmse(pred, actual):
    pred = pred[actual.nonzero()].flatten()
    actual = actual[actual.nonzero()].flatten()
    return np.sqrt(mean_squared_error(pred, actual))

"""### Calculate MAE and RMSE"""

train_subset = train_matrix[:test_similarity.shape[0], :]

test_pred = test_similarity.dot(train_subset) / np.array([np.abs(test_similarity).sum(axis=1)]).T

print('MAE:', mae(test_pred, test_matrix[:test_similarity.shape[0], :]))
print('RMSE:', rmse(test_pred, test_matrix[:test_similarity.shape[0], :]))